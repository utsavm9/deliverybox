<!DOCTYPE html>

<html>

<head>
    <meta charset="UTF-8" />
    <title>WASM for Mbed OS | ECE M202A Project</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css"
        href="https://pages-themes.github.io/cayman/assets/css/style.css?v=bab38dbfd764a3259db85a3d47696439eb22ebd3" />
    <link rel="shortcut icon" type="image/png" href="favicon.jpeg" />
    <link rel="stylesheet" type="text/css" href="index.css" />
</head>

<body>
    <header class="page-header" role="banner">
        <h1 class="project-name">WASM for Mbed OS</h1>
        <h2 class="project-tagline">Project for ECE M202A - Embedded Systems</h2>

        <a href="https://github.com/utsavm9/wasm-for-arduino-mbed" target="_blank" class="btn">GitHub Repo</a>
        <a href="https://github.com/utsavm9/wasm-for-arduino-mbed/tree/main/docs" target="_blank" class="btn">
            Website Folder
        </a>
    </header>

    <main id="content" class="main-content" role="main">

        <div class="card">
            <h1>Goals Accomplished</h1>
            <hr />

            <ul>
                <li> Ported WebAssembly Micro Runtime
                    (<a href="https://github.com/bytecodealliance/wasm-micro-runtime">WAMR</a>) to run on targets
                    supported
                    by <a href="https://os.mbed.com/mbed-os/">ARM Mbed OS</a>.</li>
                <li>Demonstrated ported WAMR works by compiling to different targets and running on one. </li>
                <li>Measured execution time of WASM interpreters on various boards.</li>
            </ul>
        </div>

        <div class="card">
            <h1>Technical Approach</h1>
            <hr />

            <p><strong>Running WAMR on Zephyr OS.</strong></p>

            <p>
                First, we got familiar with building projects for embedded systems. Getting a Blinky project running on
                Zephyr took the most time in this project. We were inexperienced
                with interacting so closely with build tools and most installed software needed to be adjusted to
                actually work. All this was further complicated by the fact
                that the latest version of CMake was buggy (<a
                    href="https://github.com/zephyrproject-rtos/zephyr/issues/30232">zephyr#30232</a>). However, Zephyr
                developers in their Slack channel helped us out.
            </p>

            <p>WAMR already supports Zephyr OS and it has a mini-product avaiable too. We had a Nordic nRF52840 DK board
                available, and so we decided to run WAMR on it. The mini-product is a sample
                program which sets-up the WAMR runtime, calls its main function and exited. Setting up a running
                baseline made us understand these key concepts about WAMR: </p>

            <ul>
                <li>A C/C++ (native) program needs to set-up WAMR runtime. This program is what we flash to the board.
                </li>
                <li>The WAMR runtime needs to know how much stack and heap its modules can have. </li>
                <li>WASM program is not sent over USB in mini-product, but its binary is encoded in a C string avaiable
                    to the native program.</li>
                <li>Our native program can pass arguments and store the result value from any function in WASM program,
                    including main().</li>
                <li>The WASM program can pass control to any functions defined natively.</li>
            </ul>

            <hr />

            <p><strong>Compiling to WASM Modules</strong></p>

            <p>
                Once we had the WASM program provided with WAMR running on Zephyr, we wanted to run our own WASM
                programs. We learnt that WASI-SDK comes with a CLang compiler which can produce WASM bytecode from C
                programs. Also, appropriate flags needed to be set so that the linker does not complain of missing
                main() when it is not needed, and also to export other functions. There exported functions has their
                definition missing from the WASM module. WAMR runtime can link functions from native program to these
                exported functions. This allows the WASM program to call any needed native functions, for example to
                blink an LED.
            </p>

            <hr />

            <p><strong>Porting WAMR to Mbed</strong></p>

            <ul>
                <li>We first needed to set-up our system so that it builds Mbed OS. We set up the toolchain and the
                    appropriate dependencies for our application. This included installing CMake, GNU ARM, and Python 3
                    with some additional packages. For our Windows machines we also had to find a workable generator for
                    CMake, which turned out to be MinGW make. </li>

                <li>We needed to incorporate together the compiling process of Mbed OS and WAMR, so that functions from
                    both were available to our native program. WAMR uses CMake as its build system. The official Mbed
                    CLI uses Python, and this was a major problem. However, we were able to find a CMake build of Mbed
                    OS, made by researchers at USC RPL. From then, we learnt CMake commands and included WAMR in the
                    middle of the CMake files of Mbed. This allowed WAMR to be a part of Mbed static OS library avaiable
                    to native programs.</li>

                <li>Next, we needed to implement platform abstraction layer in WAMR. All of the OS dependent functions
                    have been seperated down to a few functions, and the rest of WAMR is OS independent. We implemented
                    the API required for WAMR interpretor.</li>
            </ul>

            <hr />

            <p><strong>Comparing Different WASM Interpretors</strong></p>

            <p>
                With WAMR interpretor now avaiable on Mbed devices, we wrote a recursive Fibonacci
                function on all the boards we had:
            </p>
            <ul>
                <li>WAMR</li>
                <ul>
                    <li>Zephyr OS on Nordic nRF52840-DK</li>
                    <li>Mbed OS on STM32 Nucleo F411-RE</li>
                </ul>
                <li>WASM3</li>
                <ul>
                    <li>
                        Mbed OS on Arduino Nano 33 BLE
                    </li>
                </ul>
            </ul>

            <p>
                WASM3 supports Arduino Nano 33 and is avaiable to use though Arduino IDE. However, it only consists of
                an interpretor, while our WAMR porting to Mbed can be extended to allow WAMR JIT, WAMR AoT and its
                libraries avaiable on targets supported by Mbed.
            </p>

        </div>

        <div class="card">
            <h1>Results</h1>
            <hr />

            <p>The forks of WAMR and Mbed-CMake with commits to make the porting work are described in our <a
                    href="https://github.com/utsavm9/wasm-for-arduino-mbed">Github repo's README</a>. Scripts to aid in
                the development process are also avaiable.</p>

            <p>
                The <kbd>builds/</kbd> <a
                    href="https://github.com/utsavm9/wasm-for-arduino-mbed/tree/main/builds">folder</a> in the repo
                contains two binaries with WAMR. Both of them were successfully compiled using
                our build system for Mbed and WAMR. Both of then are built from the same native and WASM program, but
                are target to two different boards: STM32 Nucleo and Arduino Nano 33.
            </p>

            <p>
                We were able to verify implementation by running it on STM32 Nucleo board. <a
                    href="https://github.com/utsavm9/wasm-for-arduino-mbed/tree/main/builds">Results and details</a> are
                added in the Github repo. Since STM32 Nucleo board is Mbed-enabled, we were able to run our binary
                without worrying about the bootloader. The output demonstrated that WAMR is now running on Mbed device
                using Mbed's libraries.
            </p>

            <details>
                <summary> <b>â€º See output from provided mini-product for Mbed</b></summary>
                <p><a
                        href="https://github.com/utsavm9/wasm-for-arduino-mbed/blob/main/measurements/stm32_mbed_wamr.cpp">stm32_mbed_wamr.cpp</a>
                    set up WAMR to run WASM module of <a
                        href="https://github.com/utsavm9/wasm-for-arduino-mbed/blob/main/measurements/fib_timed.c">fib_timed.c</a> on a STM32F411 Nucleo board.
                </p>
                <img src="https://raw.githubusercontent.com/utsavm9/wasm-for-arduino-mbed/main/docs/output.png" />
            </details>


        </div>

        <div class="card">
            <h1>Strenths and Possible Improvements</h1>
            <hr />

            <p>
                <b>Strengths</b>:
            </p>
            <ul>
                <li>WAMR now runs on <a href="https://github.com/utsavm9/mbed-cmake/tree/master/mbed-src/targets">all
                        targets supported by Mbed-CMake</a>, which include numerous boards including those from
                    Nordic, STM, NXP, Renesas among others.</li>
            </ul>

            <p>
                <b>Possible Improvements</b>:
            </p>
            <ul>
                <li>We identified how to attach a J-Link debugger to our Arduino Nano 33 board and figured out at what
                    offset we might have flashed it. Resources collected in the <a
                        href="https://github.com/utsavm9/wasm-for-arduino-mbed/tree/main/builds">builds folder</a> of
                    our repo. If we could solder well, WAMR binary could be run on Arduino Nano 33 board.
                </li>
                <li>Our implementation currently does not make avaiable the Arduino libraries. While there have been
                    many CMake build systems for Arduino, many of them have been abandoned. If a CMake built system of
                    Arduino is avaiable with the support for recent lauched<a
                        href="https://github.com/arduino/ArduinoCore-mbed">ArduinoCore-mbed</a>, then that build system
                    can be integrated into Mbed-CMake to have Arduino libraries also avaiable to the native program.
                </li>
                <li>WAMR AoT compiler would be faster than the currently ported WAMR Interpretor, and is therefore of
                    much interest. By implementing <kbd>mmap</kbd> and related functions in the platform API layer, AoT
                    would be avaiable on WAMR for Mbed.</li>
                <li>By implementing the platform API extension available on WAMR, support for multi-threaded WASM
                    applications along with applicatoin framework and remote application management would be avaiable in
                    WAMR for Mbed.</li>
            </ul>
        </div>

        <div class="card">
            <h1>Existing Literature on WAMR</h1>
            <hr />
            <p>
                WebAssembly's popularity has increased and with that so has the research into other applications of the
                binary instruction format. Despite its benefits, WebAssembly has been shown to be 45% slower than its
                native commponent
                <span class="tooltip"
                    title='"A. Jangda, B. Powers, E. D. Berger and A. Guha, " Not so fast: Analyzing the performance of webassembly vs. native code", 2019 {USENIX} Annual Technical Conference ({USENIX}{ATC}19), pp. 107-120, 2019."'>
                    [1]</span>
                </span>.</p>
            <p>

                This project invokes WAMR, but other run-times also exist. WASI has been created to be the run time
                that accesses and executes systems calls <span class="tooltip"
                    title='E. Wen and G. Weber, "Wasmachine: Bring IoT up to Speed with A WebAssembly OS," 2020 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops), Austin, TX, USA, 2020, pp. 1-4, doi:10.1109/PerComWorkshops48775.2020.9156135.'>
                    [2]
                </span>. Work such as the IoT OS, Wasmachine
                has been created to be "a secure runtime/OS aiming to run WebAssembly applications faster than
                bare-metal machine"<span class="tooltip"
                    title='E. Wen and G. Weber, "Wasmachine: Bring IoT up to Speed with A WebAssembly OS," 2020 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops), Austin, TX, USA, 2020, pp. 1-4, doi:10.1109/PerComWorkshops48775.2020.9156135.'>
                    [2]
                </span>.
            </p>
            <p>
                While benenficial in terms of timing using its ahead-of-time approach, it could
                be some
                time before Wasmachine could be deployed. In additional research work has been made by the partnership
                of Mozill, Red Hat, Intel, and Fastly. Together, the Bytecode Alliance, has made progress in areas of
                code generation, run-time,
                and micro-runtime. Their work with the WebAssembly MicroRuntime (WAMR) has been created for Linux,
                macOS, Zephyr, AliOS Things, and VxWorks and has support for x86_32, x86_64, Arm, and MIPS <span
                    class="tooltip"
                    title='Bytecode Alliance, 2019. [Online]. Available:https://bytecodealliance.org/. [Accessed: 01-Dec-2020].'>
                    [3]
                </span>. Like
                Wasmachine, it uses an AOT approach
                to improve speed. This project's work uses the WAMR Porting Guide to port WAMR to a non-supported
                platform, Mbed OS. This work will compare the timing results and include documentation to support
                the
                changes made for the this platform.
            </p>

        </div>

        <div class="card">
            <h1>Team Members and Contributions</h1>
            <hr />

            <ul>
                <li>
                    <a href="mailto:arelysnavarro@g.ucla.edu"> Arelys Navarro </a>
                    <ul>
                        <li>Porting Mbed to Arduino - File configuration, testing, and compiling.</li>
                        <li>Using WASM3 - Debugging</li>
                        <li>Research - References reserch, timing comparisons of other implementations, AOT vs JIT
                            research</li>
                        <li>Final Documentation - Presentation, report</li>
                    </ul>
                </li>
                <li>
                    <a href="mailto:howardx@g.ucla.edu"> Howard Xie </a>
                    <ul>
                        <li>Using WASM3</li>
                        <ul>
                            <li>Adapted Wasm3 to our project</li>
                            <li>Wrote program and compiled to WebAssembly</li>
                            <li>Ran WASM program on Arduino using Wasm3 interpreter</li>
                            <li>Recorded timing for evaluation</li>
                        </ul>
                        <li>Final Documentation - Presentation, report</li>
                    </ul>
                </li>
                <li>
                    <a href="mailto:utsavm9@g.ucla.edu"> Utsav Munendra </a>
                    <ul id="utsav">
                        <li>Ran WAMR on Zephyr OS</li>
                        <li>Combined CMake files of WAMR and Mbed</li>
                        <li>Coded the platform API layer of WAMR for Mbed</li>
                        <li>Wrote scripts, made graphs, managed Git repo</li>
                        <li>Website code and content</li>
                        <li>ðŸ”¥Burnt off metal pads on two Arduino boards while solderingðŸ”¥</li>
                    </ul>
                </li>
            </ul>
        </div>


    </main>
</body>

</html>