<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8" />
        <title>WASM for Arduino/Mbed | ECE M202A Project</title>

        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link
            rel="stylesheet"
            type="text/css"
            href="https://pages-themes.github.io/cayman/assets/css/style.css?v=bab38dbfd764a3259db85a3d47696439eb22ebd3"
        />
        <link rel="shortcut icon" type="image/png" href="favicon.jpeg" />
        <link rel="stylesheet" type="text/css" href="index.css" />
    </head>

    <body>
        <header class="page-header" role="banner">
            <h1 class="project-name">WASM for Arduino/Mbed</h1>
            <h2 class="project-tagline">Project for ECE M202A - Embedded Systems</h2>

            <a href="https://github.com/utsavm9/wasm-for-arduino-mbed" target="_blank" class="btn">GitHub Repo</a>
            <a href="https://github.com/utsavm9/wasm-for-arduino-mbed/tree/main/docs" target="_blank" class="btn">
                Website Folder
            </a>
        </header>

        <main id="content" class="main-content" role="main">
            <div class="card">
                <h1>Proposal Abstract</h1>
                <hr />

                <p>
                    Our goal in this project is to develop a sensor interface that would allow a WebAssembly Runtime to
                    run WebAssembly application on an Arduino Nano 33 BLE Sense (nRF5280) board and be able to utilize the sensors present on the
                    board. Applications run inside a WebAssembly runtime are more secure than C applications compiled to
                    run natively. We want to use the security features present in a WebAssembly runtime and develop
                    applications which once compiled to WebAssembly, can execute on different boards. The main challenge
                    we face in this project is getting WebAssembly to work full-fledged on Arduino/Mbed embedded device
                    so that the application can access and control the sensors present on the board. We want WebAssembly
                    running on our embedded device and have it communicate with the proper pinouts on the device.
                </p>

                <p>
                    We also plan to quantify any additional memory overhead or runtime costs that are by using a
                    WebAssemblytime as opposed to compiling and running executables natively.
                </p>

                <p>
                    <b>Deliverables</b>: A Sensor interface to existing WebAssembly Runtime targeted to run on
                    Andruino/Mbed, this includes our code and appropriate ReadMe's.
                </p>
            </div>

            <div class="card">
                <h1>Proposed Timeline</h1>
                <hr />

                <ul>
                    <li>Week 5 (11/6): Meet with Botong Ou for guidance and collect baseline board</li>
                    <li>Week 6 (11/09): Analyse existing literature and add it to the report.</li>
                    <li>Week 6 (11/10): Have WASM running on Zephyr OS device for reference</li>
                    <li>
                        Week 6 (11/13): Learn how WASI-SN works with Zephyr, and figure out what we need to code to make
                        it work for Arduino.
                    </li>
                    <li>Week 7: Report on preliminary design and results.</li>
                    <li>Week 8 (11/27): Have a WebAssembly Runtime working on our Arduino board.</li>
                    <li>Week 9 (12/04): Measure statistics on the overheads introduced by using WebAssembly</li>
                    <li>Week 10 (12/11): Finish project report and code.</li>
                    <li>Week 11 (12/18): Finish the video presentation.</li>
                </ul>
            </div>
            
             <div class="card">
                <h1>Project Goals</h1>
                <hr />

                <p>
                   Develop a sensor interface that would allow WebAssembly Micro Runtime (WAMR) to run a WebAssembly application on an Arduino/Mbed OS.
                     <li>Porting WAMR to Mbed OS
                     <li>Evaluate WAMR on Mbed OS
                </p>

                
            </div>
            
             <div class="card">
                <h1>Technical Approach</h1>
                <hr />
                <p>
                   <ol>
                       <li>Running WebAssembly Micro Runtime (WAMR) on Zephyr Real Time Operating System (RTOS)</li>
                           
                       <li>Porting WAMR to Mbed OS</li>
                          
                       <li>Evaluate WAMR on Mbed OS</li>
                           
                   </ol>
                </p>
                <p>
                    Hardware
                   <li>Arduino Nano 33 BLE Sense
                   <li>Micro USB Cable
                   <li>NUCLEO-F411RE Board
                   <li>USB Mini-B to USB-A Cable
                   <li>LED
                   <li>Adafruit SWD Cable Breakout Board
                   <li>Breadboard
                   <li>Jumper Cables
                   <li>Soldering kit
                </p>

                
            </div>
            
             <div class="card">
                <h1>Implementation, Evaluation, Success Metrics, and Key Findings</h1>
                <hr />
                 <p>
                    Implementation:
                 <ol>
                       <li>Running WebAssembly Micro Runtime (WAMR) on Zephyr Real Time Operating System (RTOS)</li>
                            Using code from ByteCode Alliance, WAMR was set up for Zephyr OS...This helped in understanding WAMR....because.... Main lessons from implementing this were....For more detail about this implementation see doc....
                       </li>
                       <li>Porting WAMR to Mbed OS</li>
                            We ported WAMR using files from....This requeired adjustment for Mbed OS API..We did not need to include math library or...Might talk about nucleo....Jtag setup....
                       </li>
                       <li>Evaluate WAMR on Mbed OS</li>
                            After succesful implementation of the code, as shown in demonstration, we implemented code for timing...Timing inludes from (start) to (end)....in all timing comparisons we used the same Fibonacci 21...                       
                       </li>
                       <li>Evaluate WASM3 and Compare to WAMR on MBed</li>
                            <p>
                                Wasm3 is a WASM interpreter that runs on embedded devices such as Arduinos. In our project, 
                                we used Wasm3 as a reference point for the ported version of WAMR. In order to use Wasm3 for 
                                testing the speed, we had to write an Arduino program that uses Wasm3 to execute a custom WASM 
                                app that we wrote. The custom WASM app was written in C++ and then compiled to WASM. The WASM 
                                app computes the 24th fibonnaci number in a recursive and time-consuming manner.
                            </p>

                            <p>
                                The process of writing a program to be compiled to WASM is as follows. First, we write a C++ 
                                <a href="https://github.com/utsavm9/wasm-for-arduino-mbed/blob/main/wasm3-arduino/wasm_apps/custom_app/app.cpp">program</a> 
                                in the form of an Arduino program with <span style="font-family: 'Courier New', Courier, monospace;">loop()</span> and 
                                <span style="font-family: 'Courier New', Courier, monospace;">setup()</span> functions. The main difference is that there 
                                is an <span style="font-family: 'Courier New', Courier, monospace;">arduino_api.h</span> and a 
                                <span style="font-family:'Courier New', Courier, monospace;">WASM_EXPORT _start()</span> function. Once the C++ 
                                program is written, we can now compile it to WASM code. This is done via the 
                                <span style="font-family: 'Courier New', Courier, monospace;">build.sh</span> script. 
                                The dependencies in the script include things like wasicc, which compiles C++ to WebAssembly.
                            </p>
                       </li>   
                   </ol>
                </p>
                <p>
                   Evaluation:
                </p>
                <p>
                   Success Metrics and Key Findings:
                </p>


                
            </div>

            <div class="card">
                <h1>Relevant Work and Resources</h1>
                <hr />
                <p>
                    WebAssembly's popularity has increased and with that so has the research into other applications of the binary instruction format. Despite its benefits, WebAssembly has been shown to be 45% slower than its native commponent when 
                    [1]. This project invokes WAMR, but other run-times also exist.  WASI has been created to be the run time that accesses and executes systems calls [2]. Work such as the IoT OS, Wasmachine 
                    has been created to be "a secure runtime/OS aiming to run WebAssembly applications faster than bare-metal machine"[2]. While benenficial in terms of timing using its ahead-of-time approach, it could be some
                    time before Wasmachine could be deployed. In additional research work has been made by the partnership of Mozill, Red Hat, Intel, and Fastly. Together, the Bytecode Alliance, has made progress in areas of code generation, run-time, 
                    and micro-runtime. Their work with the WebAssembly MicroRuntime (WAMR) has been created for Linux, macOS, Zephyr, AliOS Things, and VxWorks and has support for x86_32, x86_64, Arm, and MIPS [3]. Like Wasmachine, it uses an AOT approach 
                    to improve speed. This project's work uses the WAMR Porting Guide to port WAMR to a non-supported platform, Mbed OS. This work will compare the timing results and include documentation to support the changes made for the this platform.
                </p>
                <ul>
                    <li>
                        <a href="https://github.com/bytecodealliance/wasm-micro-runtime"> WebAssembly Micro Runtime </a>
                    </li>
                    <li>
                        <a href="https://github.com/conix-center/edge-rm/tree/master/agent/zephyr/app">
                            Edge Resource Manager - Zephyr Agent Application
                        </a>
                    </li>
                    <li>
                        <a
                            href="https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/build_wamr.md#zephyr"
                        >
                            Running WAMR on board with Zephyr OS
                        </a>
                    </li>
                </ul>
            </div>
            
            <div class="card">
                <h1>Strenths and Weaknesses</h1>
                <hr />

                <p>
                    Strengths:
                    
                </p>

                <p>
                    Weaknessess:
                    
                </p>

                
            </div>

            <div class="card">
                <h1>Team Members and Contributions</h1>
                <hr />

                <ul>
                    <li>
                        <a href="mailto:arelysnavarro@g.ucla.edu"> Arelys Navarro </a>
                        Porting Mbed to Arduino - File configuration, testing, and compiling.
                        WASM3 Implementation - Debugging
                        Research - References reserch, timing comparisons of other implementations, AOT vs JIT research
                        Final Documentation - Presentation, report
                    </li>
                    <li>
                        <a href="mailto:howardx@g.ucla.edu"> Howard Xie </a>
                        WASM3 Implementation - compliing, code, recording data for evaluation
                        Final Documentation - Presentation, report
                    </li>
                    <li>
                        <a href="mailto:utsavm9@g.ucla.edu"> Utsav Munendra </a>
                        Zephyr Implementation - Zephyr setup and compilation
                        Porting Mbed to Arduino - Final complilation of WAMR 
                        Mbed on Nucleo - WAMR setup
                        Final Documentation - Presentation, report
                    </li>
                </ul>
            </div>
            
             <div class="card">
                <h1>Important Links</h1>
                <hr />

                <ul>
                    <li>
                        <a href="https://github.com/bytecodealliance/wasm-micro-runtime"> Final Presentation PDF </a>
                    </li>
                    <li>
                        <a href="https://github.com/conix-center/edge-rm/tree/master/agent/zephyr/app">
                           Data Sets
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/wasm3/wasm3-arduino"> WASM3 GitHub</a>
                    </li>
                </ul>
            </div>
            
             <div class="card">
                <h1>References</h1>
                <hr />
                    <p>
                        <ol>
                            <li>A. Jangda, B. Powers, E. D. Berger and A. Guha, "Not so fast: Analyzing the performance of webassembly vs. native code", 2019 {USENIX} Annual Technical Conference ({USENIX}{ATC}19), pp. 107-120, 2019.</li>
                            <li>E. Wen and G. Weber, "Wasmachine: Bring IoT up to Speed with A WebAssembly OS," 2020 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops), Austin, TX, USA, 2020, pp. 1-4, doi: 10.1109/PerComWorkshops48775.2020.9156135.</li>
                            <li>Bytecode Alliance, 2019. [Online]. Available: https://bytecodealliance.org/. [Accessed: 01-Dec-2020]. </li>
                        </ol/
                     </p>

                <ul>
                    <li>
                        <
                    </li>
                </ul>
            </div>
        </main>
    </body>
</html>
